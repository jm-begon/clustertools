#!/usr/bin/env python

import argparse
import datetime
import pickle
import time
import os
import re
import socket
from abc import abstractmethod, ABCMeta, abstractclassmethod
from collections import OrderedDict

import sys

import subprocess

import dill

from clustertools import Experiment
from clustertools import Monitor
from clustertools import build_datacube
from clustertools import shutup_logger
from clustertools.parser import or_none
from clustertools.storage import PickleStorage, Architecture,\
    ComputationInfoPrinter

__author__ = "Begon Jean-Michel <jm.begon@gmail.com>"
__copyright__ = "3-clause BSD License"

__LH__ = "localhost"
__WC__ = "*"

query_doc = "The query. Use ssh-like syntax: \
'luke@skywalker:exp_about_the_force'. The first part can \
be omitted for local survey."
queries_doc = query_doc + " A wildcard '{}' can be used to list all the \
experiment.".format(__WC__)


# ================================= UTILITIES ================================ #
def split_host_and_exp(query):
    try:
        host, exp_name = query.split(":")
    except ValueError:
        host = None
        exp_name = query
    return host, exp_name


def rearrange_queries(queries):
    sorted_queries = OrderedDict()
    for query in queries:
        host, exp_name = split_host_and_exp(query)
        by_host = sorted_queries.get(host, None)
        if by_host is None:
            by_host = []
            sorted_queries[host] = by_host
        by_host.append(exp_name)
    return sorted_queries


def get_prog():
    return os.path.basename(sys.argv[0])


def filter_experiment(pattern=__WC__, architecture=Architecture()):
    if pattern == __WC__:
        pattern = r".*"
    regex = re.compile(pattern)
    for name in Architecture().load_experiment_names():
        if regex.search(name) is not None:
            yield name


def comp_num_to_name(exp_name, comp_name):
    try:
        comp_num = int(comp_name)
        comp_name = Experiment.name_computation(exp_name, comp_num)
    except ValueError:
        pass
    return comp_name


# ================================== SUBPROG ================================= #
# ----------------------------- Vanilla subprog ------------------------------ #
class SubProg(object, metaclass=ABCMeta):

    @property
    @abstractmethod
    def subprog_name(self):
        """Return the program name"""
        pass

    @abstractmethod
    def fill_in_subparser_(self, sub_parser):
        """Fill the given sub_parser with the program arguments"""
        pass

    def fill_in_subparser(self, main_parser):
        sub_parser = main_parser.add_parser(self.subprog_name)
        self.fill_in_subparser_(sub_parser)
        sub_parser.set_defaults(func=self.run)
        return sub_parser

    @abstractmethod
    def run(self, namespace):
        pass


class Syncher(SubProg):
    @property
    def subprog_name(self):
        return "sync"

    def fill_in_subparser_(self, sub_parser):
        source_doc = """The source.
        Use scp-like syntax: 'luke@skywalker:exp_about_the_force' to specify
        that you are targeting experiment 'exp_about_the_force' on machine
        'skywalker' where your id is 'luke'. Use a dot '.' for localhost."""
        dest_doc = """The destination.
        Use the syntax: 'vador@deathstar' to specify that you the destination is
        machine 'deathstar' where your id is 'vador'. Use a dot '.' for
        localhost."""

        sub_parser.add_argument("source", help=source_doc)
        sub_parser.add_argument("destination", help=dest_doc)
        sub_parser.add_argument("--quiet", "-q", default=False,
                                action="store_true",
                                help="Runs in quiet mode.")
        sub_parser.add_argument("--test", "-t", default=False,
                                action="store_true",
                                help="print the command instead of running it.")

    def run(self, namespace):
        # Getting source and destination
        source_info = namespace.source.split(":")
        dest_info = namespace.destination.split(":")

        destination_machine = ''
        if len(source_info) == 1:
            source_machine = "."
            experiment = source_info[0]
        else:
            source_machine, experiment = source_info

        if len(dest_info) == 1 or (
                len(dest_info) == 2 and len(dest_info[1]) == 0):
            destination_machine = dest_info[0]
        elif experiment is not None:
            raise ValueError("Only the source can specify an experiment.")

        print("Transferring {} from {} to {}".format(experiment, source_machine,
                                                     destination_machine))

        # TODO
        if source_machine == '.':
            source_prefix = os.path.expanduser("~") + "/"
        else:
            source_prefix = source_machine + ':'
        if destination_machine == '.':
            destination_prefix = os.path.expanduser("~") + "/"
        else:
            destination_prefix = destination_machine + ':'

        # TODO do something more portable
        ct_folder = 'clustertools_data'
        source_str = source_prefix + \
                     Architecture(ct_folder).get_basedir(experiment) + '/'
        destination_str = destination_prefix + \
                          Architecture(ct_folder).get_basedir(experiment)

        if namespace.quiet:
            r_args = "-azh"
        else:
            r_args = "-azhP"

        cmd = "rsync {r_args} {source} {dest}".format(r_args=r_args,
                                                      source=source_str,
                                                      dest=destination_str)

        if namespace.test:
            print(cmd)
        else:
            subprocess.call(cmd, shell=True)


# ------------------------------ Remote subprog ------------------------------ #
class Routine(object):
    """
    `Routine`
    ==========
    A `Routine` represents a subprogram and its command line variables. The
    routine can be local or can be run across the network.

    Its responsibility is to
        1. store the relevant parameters (in their final form)
        2. run the subroutine it resprents
        3. craft a remote query

    """
    def __init__(self, host, subprog):
        self._host = host
        self._subporg = subprog

    @property
    def host(self):
        return self._host

    @property
    def subprog(self):
        return self._subporg

    def craft_remote_query(self):
        """
        Returns
        -------
        query: str
            The string corresponding to the remote query of this routine
        """
        return "ssh {host} '{str}'" \
               "".format(host=self.host if self.host is not None else __LH__,
                         str=str(self))

    def __str__(self):
        return "{} {}".format(get_prog(), self.subprog)

    def run(self):
        if self.host is None:
            # Local routine
            self()
        else:
            # Remote routine
            remote_query = self.craft_remote_query()
            # print(remote_query)
            subprocess.call(remote_query, shell=True)

    @abstractmethod
    def __call__(self):
        pass


class RemotableSubProg(SubProg, metaclass=ABCMeta):
    """
    `RemotableSubProg`
    ==================
    A `RemotableSubProg` instance represents a sub program which can be run
    locally or remotely.

    Its responsibility is to offer a subprogram with an interface in agreement
    with the :meth:`crate_remote_query` method of the `Routine` class it is
    working with, to handle appropriate parsing and to run the `Routine`
    instances.

    A Program might handle several queries but this is not necessarily the case.
    """

    @abstractmethod
    def to_queries(self, **kwargs):
        pass

    def run(self, namespace):
        for query in self.to_queries(**vars(namespace)):
            query.run()


# ----------------------------------------------------------------- Single query

class ToLaunchable(RemotableSubProg):
    class ToLaunchableRoutine(Routine):
        def __init__(self, host, subprog, exp_name, comp_name):
            super().__init__(host, subprog)
            self.exp_name = exp_name
            self.comp_name = comp_name

        def __str__(self):
            return "{prog} {subprog} {exp_name} {comp_name}" \
                   "".format(prog=get_prog(),
                             subprog=self.subprog,
                             exp_name=self.exp_name,
                             comp_name=self.comp_name)

        def __call__(self):
            before, after = Monitor(self.exp_name).to_launchable(self.comp_name)
            print("{}: {} --> {}".format(self.comp_name, before, after))

    @property
    def subprog_name(self):
        return "launchable"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("query", help=query_doc)
        sub_parser.add_argument("computation",
                                help="Computation name or number")

    def to_queries(self, query, computation, **kwargs):
        host, exp_name = split_host_and_exp(query)

        comp_name = comp_num_to_name(exp_name, computation)

        return [self.ToLaunchableRoutine(host, self.subprog_name, exp_name,
                                         comp_name)]


class Displayer(RemotableSubProg):
    class PrintRoutine(Routine):
        def __init__(self, host, subprog, type, exp_name, comp_name,
                     last_lines):
            super().__init__(host, subprog)
            self.type = type
            self.exp_name = exp_name
            self.comp_name = comp_name
            self.last_lines = last_lines

        def __repr__(self):
            return "{cls}(host={host}, subprog={subprog}, type={type}," \
                   "exp_name={exp_name}, comp_name={comp_name}, " \
                   "last_lines={last_lines})" \
                   "".format(cls=self.__class__.__name__,
                             host=repr(self.host),
                             subprog=repr(self.subprog),
                             type=repr(self.type),
                             exp_name=repr(self.exp_name),
                             comp_name=repr(self.comp_name),
                             last_lines=repr(self.last_lines))

        def __str__(self):
            last_lines = ""
            if self.last_lines is not None:
                last_lines = "--last-line {}".format(self.last_lines)
            return '{prog} {subprog} {last_lines} ' \
                   '{type} {exp_name} {comp_name}' \
                   ''.format(prog=get_prog(),
                             subprog=self.subprog,
                             last_lines=last_lines,
                             type=self.type,
                             exp_name=self.exp_name,
                             comp_name=self.comp_name)

        def __call__(self):
            storage = PickleStorage(self.exp_name)
            if self.type == "log":
                storage.print_log(self.comp_name, last_lines=self.last_lines)
            elif self.type == "state":
                    fpath = os.path.join(storage._get_notif_db(),
                                         "{}.pkl".format(self.comp_name))
                    with open(fpath, "rb") as handle:
                        try:
                            raw = pickle.load(handle)
                        except Exception:
                            raw = dill.load(handle)
                        print(repr(raw))

            else:
                long_info = self.type == "long_info"
                ComputationInfoPrinter(self.exp_name, self.comp_name,
                                       long_info=long_info).print()

    @property
    def subprog_name(self):
        return "display"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("type", choices=["info", "long_info", "state",
                                                 "log"])
        sub_parser.add_argument("query", help=query_doc)
        sub_parser.add_argument("computation",
                                help="Computation name or number")
        sub_parser.add_argument("--last-lines",
                                help="Number of line to print or "
                                     "None (default: None)",
                                type=or_none(int), default=None)

    def to_queries(self, type, query, computation, last_lines=None, **kwargs):
        host, exp_name = split_host_and_exp(query)

        comp_name = comp_num_to_name(exp_name, computation)

        return [self.PrintRoutine(host, self.subprog_name, type, exp_name,
                                  comp_name, last_lines)]


# ------------------------------------------------------------- Multiple queries
class Version(RemotableSubProg):
    class VersionRoutine(Routine):
        def __call__(self):
            import clustertools
            print(clustertools.__version__)

    @property
    def subprog_name(self):
        return "version"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("queries", help="Hostnames to get the version "
                                                "(leave empty for localhost)",
                                nargs="*")

    def to_queries(self, queries, **kwargs):
        if len(queries) == 0:
            # Localhost
            yield self.VersionRoutine(None, self.subprog_name)
        else:
            for host in queries:
                yield self.VersionRoutine(host, self.subprog_name)


class Diagnoser(RemotableSubProg):
    class DiagnoseRoutine(Routine):
        def __init__(self, host, subprog, *exp_names):
            super().__init__(host, subprog)
            self.exp_names = exp_names

        def __str__(self):
            return "{prog} {subprog} {exp}" \
                   "".format(prog=get_prog(),
                             subprog=self.subprog,
                             exp=" ".join(self.exp_names))

        def __call__(self):
            for exp_name in self.exp_names:
                cube = build_datacube(exp_name)
                print("{} -- {}".format(cube.name, cube.diagnose()))

    @property
    def subprog_name(self):
        return "diagnose"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("queries", help=queries_doc, nargs="*")

    def to_queries(self, queries, **kwargs):
        for host, exp_names in rearrange_queries(queries).items():
            yield self.DiagnoseRoutine(host, self.subprog_name, *exp_names)


class ListComputations(RemotableSubProg):
    # TODO encapsulate more the state strings
    class ListRoutine(Routine):
        def __init__(self, host, subprog, exp_name, state_str):
            super().__init__(host, subprog)
            self.exp_name = exp_name
            self.state_str = state_str

        def __str__(self):
            return "{prog} {subprog} {exp_name} {state_str}" \
                   "".format(prog=get_prog(),
                             subprog=self.subprog,
                             exp_name=self.exp_name,
                             state_str=self.state_str)

        def __call__(self):
            monitor = Monitor(self.exp_name)
            if self.state_str == "aborted":
                s = monitor.aborted_computations()
            elif self.state_str == "incomplete":
                s = monitor.incomplete_computations()
            elif self.state_str == "launchable":
                s = monitor.launchable_computations()
            elif self.state_str == "critical":
                s = monitor.critical_computations()
            elif self.state_str == "unlaunchable":
                s = monitor.unlaunchable_comp_names()
            else:
                raise AttributeError("Unknown state '{}'".format(self.state_str))
            if len(s) == 0:
                print("No computation in {} state".format(self.state_str))
            for el in s:
                print(el)

    @property
    def subprog_name(self):
        return "list"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("state", choices=["launchable", "unlaunchable",
                                                  "aborted", "incomplete",
                                                  "critical"],
                                help="The state of the computation to list")
        sub_parser.add_argument("query", help=query_doc)

    def to_queries(self, query, state, **kwargs):
        host, exp_name = split_host_and_exp(query)
        return [self.ListRoutine(host, self.subprog_name, exp_name, state)]


class Counter(RemotableSubProg):
    class CounterRoutine(Routine):
        def __init__(self, host, subprog, n_progress, exp_name, *exp_names):
            super().__init__(host, subprog)
            self.exp_names = [exp_name] + list(exp_names)
            self.n_progress = n_progress

        def __str__(self):
            return "{prog} {subprog} -n {n_progress} {exp}" \
                   "".format(prog=get_prog(),
                             subprog=self.subprog,
                             n_progress=self.n_progress,
                             exp=" ".join(self.exp_names))

        def __call__(self):
            try:
                hostname = socket.gethostname()
            except Exception:
                hostname = "Unknown host"
            print(hostname, ":")
            def shorten(comp_name):
                return "Comp[...]-{}".format(comp_name.split("-")[-1])

            for exp_name in self.exp_names:
                for name in filter_experiment(exp_name):
                    try:
                        monitor = Monitor(name)
                        print("\t", name, monitor.count_by_state())
                        for i, (comp_name, progress_monitor) in enumerate(
                                monitor.get_working_progress().items()):
                            print("\t\t{} - {}".format(shorten(comp_name),
                                                       str(progress_monitor)))
                            if i >= args.n_progress:
                                print("\t\t...")
                                break
                    except Exception as e:
                        print("\t {} ??? ({})".format(name, repr(e)))

    @property
    def subprog_name(self):
        return "count"

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("queries", help=queries_doc, nargs="*")
        sub_parser.add_argument("-l", "--loop", default=-1, type=int,
                                help="Number of minute to wait between two "
                                     "refreshment. Set to negative (default) "
                                     "for no refreshment.")
        sub_parser.add_argument("-n", "--n-progress", default=10, type=int,
                                help="Number of lines of progress to show per "
                                     "experiment")

    def to_queries(self, queries, n_progress, **kwargs):
        if len(queries) == 0:
            yield self.CounterRoutine(None, self.subprog_name, n_progress,
                                      __WC__)
        for host, exp_names in rearrange_queries(queries).items():
            yield self.CounterRoutine(host, self.subprog_name,
                                      n_progress, *exp_names)

    def run(self, namespace):
        if namespace.loop < 0:
            super().run(namespace)
        else:
            try:
                while True:
                    os.system("clear")
                    print(datetime.datetime.now().strftime(
                        "%A %d %h %Y %H:%M:%S"))
                    super().run(namespace)
                    time.sleep(args.loop * 60)
            except (KeyboardInterrupt, SystemExit):
                print("")
                sys.exit(0)


# ------- Monitor Action Jobs
class MonitorActionSubProg(RemotableSubProg):
    class ActionRoutine(Routine):
        def __init__(self, host, subprog, func, exp_name, *exp_names):
            super().__init__(host, subprog)
            self.exp_names = [exp_name] + list(exp_names)
            self._func = func

        def __str__(self):
            return '{prog} {subprog} {exp_names}' \
                   ''.format(prog=get_prog(),
                             subprog=self.subprog,
                             exp_names=' '.join(self.exp_names))

        def __call__(self):
            # Local
            try:
                hostname = socket.gethostname()
            except Exception:
                hostname = "Unknown host"

            for exp_name in self.exp_names:
                try:
                    monitor = Monitor(exp_name)
                    print(hostname, ":", exp_name, monitor.count_by_state(),
                          end=" ")
                    self._func(monitor)
                    monitor.refresh()
                    print("-->", monitor.count_by_state())
                except Exception:
                    print("No such experiment")

    def __init__(self, prog_name, action):
        self._prog_name = prog_name
        self._action = action

    @property
    def subprog_name(self):
        return self._prog_name

    def fill_in_subparser_(self, sub_parser):
        sub_parser.add_argument("queries", help=query_doc, nargs="*")

    def to_queries(self, queries, **kwargs):
        for host, exp_names in rearrange_queries(queries).items():
            yield self.ActionRoutine(host, self.subprog_name,
                                     self._action, *exp_names)


def aborted_2_launchable_prog_factory():
    return MonitorActionSubProg('abr2lch',
                                lambda monitor: monitor.aborted_to_launchable())


def reset_prog_factory():
    return MonitorActionSubProg('reset', lambda monitor: monitor.reset())


if __name__ == '__main__':
    shutup_logger()
    parser = argparse.ArgumentParser(
        description="General command line utility for Clustertools. The purpose"
                    " is to ease frequent tasks and to do so without a Python "
                    "interpreter."
    )
    subparsers = parser.add_subparsers(title="Subcommands",
                                       description="Valid subcommands")

    for subprog in Counter(), Syncher(), Displayer(), \
                   aborted_2_launchable_prog_factory(), reset_prog_factory(), \
                   Version(), Diagnoser(), ToLaunchable(), ListComputations():
        subprog.fill_in_subparser(subparsers)

    args = parser.parse_args()
    if not hasattr(args, "func"):
        parser.print_help()
    else:
        args.func(args)
